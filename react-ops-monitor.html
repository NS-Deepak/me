<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Ops Monitor V2 - React Version</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script crossorigin src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <style>
        .crt-lines {
            position: absolute;
            inset: 0;
            background: linear-gradient(rgba(18, 16, 16, 0) 50%, rgba(0, 0, 0, 0.25) 50%), linear-gradient(90deg, rgba(255, 0, 0, 0.06), rgba(0, 255, 0, 0.02), rgba(0, 0, 255, 0.06));
            background-size: 100% 2px, 3px 100%;
            pointer-events: none;
            z-index: 150;
        }
    </style>
</head>

<body class="bg-[#050505]">
    <div id="root"></div>

    <script type="text/babel">
        const { useEffect, useRef } = React;

        function App() {
            const mountRef = useRef(null);


            useEffect(() => {
                if (!mountRef.current) return;

                // --- Scene setup ---
                const scene = new THREE.Scene();

                // --- Camera ---
                const camera = new THREE.PerspectiveCamera(
                    45,
                    window.innerWidth / window.innerHeight,
                    0.1,
                    1000
                );
                const initialDistance = window.innerWidth < 768 ? 11 : 6;
                camera.position.set(0, 0, initialDistance); // Better viewing angle, responsive to mobile

                // --- Renderer ---
                const renderer = new THREE.WebGLRenderer({ antialias: true });
                renderer.setSize(window.innerWidth, window.innerHeight);
                renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
                renderer.shadowMap.enabled = true;
                renderer.shadowMap.type = THREE.PCFSoftShadowMap;
                mountRef.current.appendChild(renderer.domElement);

                // --- Lighting ---
                const ambientLight = new THREE.AmbientLight(0xffffff, 0.1);
                scene.add(ambientLight);

                const sunLight = new THREE.DirectionalLight(0xffffff, 2.0); // Brighter sun
                sunLight.position.set(10, 5, 5);
                // Shadows disabled as per user request
                scene.add(sunLight);

                // --- Earth Group ---
                const earthGroup = new THREE.Group();
                scene.add(earthGroup);
                earthGroup.position.x = 0; // Center Earth

                // --- Earth with realistic materials ---
                const loader = new THREE.TextureLoader();

                // Load Real NASA Assets
                const dayTexture = loader.load('https://raw.githubusercontent.com/mrdoob/three.js/master/examples/textures/planets/earth_atmos_2048.jpg');
                const nightTexture = loader.load('https://raw.githubusercontent.com/mrdoob/three.js/master/examples/textures/planets/earth_lights_2048.png');
                const specularTexture = loader.load('https://raw.githubusercontent.com/mrdoob/three.js/master/examples/textures/planets/earth_specular_2048.jpg');
                const cloudTexture = loader.load('https://raw.githubusercontent.com/mrdoob/three.js/master/examples/textures/planets/earth_clouds_2048.png');

                // Earth with Custom Ultra-Realistic Shader
                const earthGeometry = new THREE.SphereGeometry(1.5, 128, 128);

                const earthMaterial = new THREE.ShaderMaterial({
                    uniforms: {
                        dayTexture: { value: dayTexture },
                        nightTexture: { value: nightTexture },
                        specularMap: { value: specularTexture },
                        sunDirection: { value: new THREE.Vector3(10, 5, 5).normalize() }
                    },
                    vertexShader: `
                        varying vec2 vUv;
                        varying vec3 vNormal;
                        varying vec3 vPosition;
                        void main() {
                            vUv = uv;
                            vNormal = normalize(normalMatrix * normal);
                            vPosition = (modelViewMatrix * vec4(position, 1.0)).xyz;
                            gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                        }
                    `,
                    fragmentShader: `
                        uniform sampler2D dayTexture;
                        uniform sampler2D nightTexture;
                        uniform sampler2D specularMap;
                        uniform vec3 sunDirection;
                        varying vec2 vUv;
                        varying vec3 vNormal;
                        varying vec3 vPosition;

                        void main() {
                            vec3 dayColor = texture2D(dayTexture, vUv).rgb;
                            vec3 nightColor = texture2D(nightTexture, vUv).rgb;
                            float specularMask = texture2D(specularMap, vUv).r;

                            // Lighting calculations
                            vec3 viewDir = normalize(-vPosition);
                            vec3 normal = normalize(vNormal);
                            vec3 sunDir = normalize(sunDirection);
                            
                            float sunDot = dot(normal, sunDir);
                            float diffuse = max(0.0, sunDot);
                            
                            // Specular (Ocean shine)
                            vec3 reflectDir = reflect(-sunDir, normal);
                            float spec = pow(max(dot(viewDir, reflectDir), 0.0), 32.0);
                            vec3 specular = vec3(0.5) * spec * specularMask;

                            // Night mask
                            float nightMask = 1.0 - smoothstep(-0.15, 0.15, sunDot);
                            
                            // Day Side
                            vec3 daySide = (dayColor * (diffuse + 0.1) * 1.5) + specular;
                            
                            // Night Side
                            vec3 nightSide = nightColor * nightMask * 1.5;
                            
                            // Atmosphere Fresnel (Surface glow)
                            float fresnel = pow(1.0 - dot(viewDir, normal), 4.0);
                            vec3 atmosphereColor = vec3(0.3, 0.6, 1.0) * fresnel * 0.4 * diffuse;

                            gl_FragColor = vec4(daySide + nightSide + atmosphereColor, 1.0);
                        }
                    `
                });

                const earth = new THREE.Mesh(earthGeometry, earthMaterial);
                earth.receiveShadow = true;
                earth.castShadow = true;
                earthGroup.add(earth);

                // Cloud Layer (High-res, transparent, slightly larger)
                const cloudGeometry = new THREE.SphereGeometry(1.51, 128, 128); // Very close to surface
                const cloudMaterial = new THREE.MeshStandardMaterial({
                    map: cloudTexture,
                    transparent: true,
                    opacity: 0.8,
                    blending: THREE.AdditiveBlending,
                    side: THREE.DoubleSide
                });
                const clouds = new THREE.Mesh(cloudGeometry, cloudMaterial);
                earthGroup.add(clouds);

                // Outer Atmosphere (Halo)
                const atmosphereGeometry = new THREE.SphereGeometry(1.65, 128, 128);
                const atmosphereMaterial = new THREE.ShaderMaterial({
                    vertexShader: `
                        varying vec3 vNormal;
                        void main() {
                            vNormal = normalize(normalMatrix * normal);
                            gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                        }
                    `,
                    fragmentShader: `
                        varying vec3 vNormal;
                        void main() {
                            float intensity = pow(0.5 - dot(vNormal, vec3(0, 0, 1.0)), 4.5); // Thinner, sharper halo
                            gl_FragColor = vec4(0.3, 0.6, 1.0, intensity * 2.0);
                        }
                    `,
                    blending: THREE.AdditiveBlending,
                    side: THREE.BackSide,
                    transparent: true,
                    depthWrite: false
                });
                const atmosphere = new THREE.Mesh(atmosphereGeometry, atmosphereMaterial);
                earthGroup.add(atmosphere);

                // --- Stars ---
                const starsGeometry = new THREE.BufferGeometry();
                const starsMaterial = new THREE.PointsMaterial({
                    color: 0xffffff,
                    size: 0.15,
                    sizeAttenuation: true,
                    map: loader.load('https://threejs.org/examples/textures/sprites/disc.png'),
                    alphaTest: 0.5,
                    transparent: true,
                });

                const starsVertices = [];
                for (let i = 0; i < 8000; i++) {
                    const x = (Math.random() - 0.5) * 200;
                    const y = (Math.random() - 0.5) * 200;
                    const z = (Math.random() - 0.5) * 200;
                    starsVertices.push(x, y, z);
                }

                starsGeometry.setAttribute(
                    'position',
                    new THREE.Float32BufferAttribute(starsVertices, 3)
                );
                const stars = new THREE.Points(starsGeometry, starsMaterial);
                scene.add(stars);

                // --- Satellite (Detailed Model) ---
                // --- Satellite (Detailed Model) ---
                const satelliteGroup = new THREE.Group();
                earthGroup.add(satelliteGroup);

                // Helper: Create Wrinkled Foil Texture (Procedural)
                const createFoilTexture = () => {
                    const canvas = document.createElement('canvas');
                    canvas.width = 512;
                    canvas.height = 512;
                    const ctx = canvas.getContext('2d');
                    if (!ctx) return new THREE.Texture();

                    const grad = ctx.createLinearGradient(0, 0, 512, 512);
                    grad.addColorStop(0, '#ffd700');
                    grad.addColorStop(0.5, '#f5c500');
                    grad.addColorStop(1, '#e6b800');
                    ctx.fillStyle = grad;
                    ctx.fillRect(0, 0, 512, 512);

                    for (let i = 0; i < 2000; i++) {
                        const x = Math.random() * 512;
                        const y = Math.random() * 512;
                        const size = Math.random() * 2;
                        ctx.fillStyle = `rgba(255,255,255,${Math.random() * 0.2})`;
                        ctx.fillRect(x, y, size, size);
                    }

                    for (let i = 0; i < 60; i++) {
                        ctx.strokeStyle = `rgba(0,0,0,${Math.random() * 0.15})`;
                        ctx.lineWidth = Math.random() * 1.5;
                        ctx.beginPath();
                        ctx.moveTo(Math.random() * 512, Math.random() * 512);
                        ctx.bezierCurveTo(
                            Math.random() * 512, Math.random() * 512,
                            Math.random() * 512, Math.random() * 512,
                            Math.random() * 512, Math.random() * 512
                        );
                        ctx.stroke();
                    }

                    const texture = new THREE.CanvasTexture(canvas);
                    texture.wrapS = texture.wrapT = THREE.RepeatWrapping;
                    return texture;
                };

                // Helper: Create Solar Grid Texture (Procedural)
                const createSolarGridTexture = () => {
                    const canvas = document.createElement('canvas');
                    canvas.width = 512;
                    canvas.height = 512;
                    const ctx = canvas.getContext('2d');
                    if (!ctx) return new THREE.Texture();

                    // 1. Base solar blue (dark, rich)
                    const grad = ctx.createLinearGradient(0, 0, 512, 512);
                    grad.addColorStop(0, '#05122b');
                    grad.addColorStop(1, '#0b1d40');
                    ctx.fillStyle = grad;
                    ctx.fillRect(0, 0, 512, 512);

                    const gridSize = 64; // 8x8 cells

                    // 2. Draw Cells with slight variation
                    for (let x = 0; x < 512; x += gridSize) {
                        for (let y = 0; y < 512; y += gridSize) {
                            // Slight color variation for realism
                            const variance = Math.random() * 20 - 10;
                            const baseBlue = 40 + variance;
                            ctx.fillStyle = `rgb(10, 20, ${baseBlue})`;
                            ctx.fillRect(x + 2, y + 2, gridSize - 4, gridSize - 4);

                            // 3. Photovoltaic Busbars (The thin silver lines)
                            ctx.strokeStyle = 'rgba(200, 200, 255, 0.3)'; // Silver-ish
                            ctx.lineWidth = 1;
                            // Vertical busbars
                            for (let k = 10; k < gridSize - 4; k += 10) {
                                ctx.beginPath();
                                ctx.moveTo(x + k, y + 2);
                                ctx.lineTo(x + k, y + gridSize - 2);
                                ctx.stroke();
                            }

                            // 4. Subtle Specular Highlight per cell (fake distinct finish)
                            ctx.fillStyle = 'rgba(255, 255, 255, 0.05)';
                            ctx.fillRect(x + 2, y + 2, gridSize - 4, (gridSize - 4) * 0.3);
                        }
                    }

                    // 5. Main Frame Grid (Thick separating lines)
                    ctx.strokeStyle = '#1a1a1a'; // Dark frame
                    ctx.lineWidth = 4;
                    for (let i = 0; i <= 512; i += gridSize) {
                        ctx.beginPath(); ctx.moveTo(i, 0); ctx.lineTo(i, 512); ctx.stroke();
                        ctx.beginPath(); ctx.moveTo(0, i); ctx.lineTo(512, i); ctx.stroke();
                    }

                    // 6. Cross intersections (optional bolts/details)
                    ctx.fillStyle = '#555';
                    for (let i = 0; i <= 512; i += gridSize) {
                        for (let j = 0; j <= 512; j += gridSize) {
                            ctx.beginPath();
                            ctx.arc(i, j, 3, 0, Math.PI * 2);
                            ctx.fill();
                        }
                    }

                    const texture = new THREE.CanvasTexture(canvas);
                    texture.anisotropy = 4; // sharpen at angles
                    return texture;
                };

                const foilTex = createFoilTexture();
                const solarTex = createSolarGridTexture();

                // Materials
                const foilMaterial = new THREE.MeshStandardMaterial({
                    color: 0xffffff,
                    map: foilTex,
                    metalness: 1.0,
                    roughness: 0.3,
                    bumpMap: foilTex,
                    bumpScale: 0.005,
                });

                const panelMaterial = new THREE.MeshStandardMaterial({
                    map: solarTex,
                    metalness: 0.8,
                    roughness: 0.2,
                    emissive: 0x0a1d37,
                    emissiveIntensity: 0.5,
                });

                const grayMetalMaterial = new THREE.MeshStandardMaterial({
                    color: 0x444444,
                    metalness: 0.9,
                    roughness: 0.4
                });

                const darkMetalMaterial = new THREE.MeshStandardMaterial({
                    color: 0x111111,
                    metalness: 0.8,
                    roughness: 0.6
                });

                // 1. Main Bus (Gold Foil Box)
                const busGeometry = new THREE.BoxGeometry(0.2, 0.2, 0.3);
                const bus = new THREE.Mesh(busGeometry, foilMaterial);
                satelliteGroup.add(bus);

                // Advanced Greeble
                const tankGeo = new THREE.CylinderGeometry(0.03, 0.03, 0.08, 12);
                const tank1 = new THREE.Mesh(tankGeo, grayMetalMaterial);
                tank1.position.set(0.08, 0.08, 0);
                satelliteGroup.add(tank1);

                const tank2 = new THREE.Mesh(tankGeo, grayMetalMaterial);
                tank2.position.set(-0.08, 0.08, 0);
                satelliteGroup.add(tank2);

                const createTube = (p1, p2) => {
                    const dist = p1.distanceTo(p2);
                    const tubeGeo = new THREE.CylinderGeometry(0.005, 0.005, dist, 8);
                    const tube = new THREE.Mesh(tubeGeo, darkMetalMaterial);
                    tube.position.copy(p1).add(p2).multiplyScalar(0.5);
                    tube.lookAt(p2);
                    tube.rotation.x += Math.PI / 2;
                    return tube;
                };

                satelliteGroup.add(createTube(new THREE.Vector3(0.1, 0, 0), new THREE.Vector3(0.1, 0, 0.1)));
                satelliteGroup.add(createTube(new THREE.Vector3(-0.1, 0, 0), new THREE.Vector3(-0.1, 0, 0.1)));

                for (let i = 0; i < 8; i++) {
                    const mGeo = new THREE.BoxGeometry(0.04, 0.02, 0.04);
                    const m = new THREE.Mesh(mGeo, i % 2 === 0 ? grayMetalMaterial : darkMetalMaterial);
                    m.position.set((Math.random() - 0.5) * 0.18, -0.1, (Math.random() - 0.5) * 0.25);
                    satelliteGroup.add(m);
                }

                // 2. Solar Panels (Textured Wings)
                const createWing = (direction) => {
                    const wingGroup = new THREE.Group();
                    const segmentCount = 3;
                    const segmentWidth = 0.14;
                    const spacing = 0.16;

                    for (let i = 0; i < segmentCount; i++) {
                        const panel = new THREE.Mesh(new THREE.BoxGeometry(segmentWidth, 0.22, 0.01), panelMaterial);
                        panel.position.set((i * spacing + 0.1) * direction, 0, 0);
                        wingGroup.add(panel);

                        // Frame for depth
                        const frameGeo = new THREE.BoxGeometry(segmentWidth + 0.01, 0.23, 0.005);
                        const frame = new THREE.Mesh(frameGeo, darkMetalMaterial);
                        frame.position.copy(panel.position);
                        frame.position.z -= 0.004;
                        wingGroup.add(frame);

                        if (i < segmentCount - 1) {
                            const strut = new THREE.Mesh(new THREE.CylinderGeometry(0.005, 0.005, 0.04), darkMetalMaterial);
                            strut.rotation.z = Math.PI / 2;
                            strut.position.set((i * spacing + 0.1 + segmentWidth / 2 + 0.01) * direction, 0, 0);
                            wingGroup.add(strut);
                        }
                    }
                    return wingGroup;
                };

                satelliteGroup.add(createWing(-1));
                satelliteGroup.add(createWing(1));

                // 3. High Gain Antenna
                const dishGroup = new THREE.Group();
                const dishGeo = new THREE.SphereGeometry(0.1, 32, 12, 0, Math.PI * 2, 0, 0.6);
                const dishMat = new THREE.MeshStandardMaterial({ color: 0xcccccc, metalness: 0.8, roughness: 0.3, side: THREE.DoubleSide });
                const dish = new THREE.Mesh(dishGeo, dishMat);
                dish.rotation.x = Math.PI / 2;
                dishGroup.add(dish);

                for (let i = 0; i < 3; i++) {
                    const strut = new THREE.Mesh(new THREE.CylinderGeometry(0.003, 0.003, 0.12), darkMetalMaterial);
                    const angle = (i / 3) * Math.PI * 2;
                    strut.position.set(Math.cos(angle) * 0.04, 0.05, Math.sin(angle) * 0.04);
                    strut.rotation.x = Math.PI / 6;
                    strut.lookAt(0, 0.1, 0);
                    dishGroup.add(strut);
                }

                const feed = new THREE.Mesh(new THREE.SphereGeometry(0.015, 8, 8), darkMetalMaterial);
                feed.position.set(0, 0.08, 0);
                dishGroup.add(feed);

                dishGroup.position.set(0, 0.15, 0);
                dishGroup.rotation.x = -Math.PI / 3;
                satelliteGroup.add(dishGroup);

                // 4. Detailed Sensor/Camera
                const cameraBody = new THREE.Mesh(new THREE.CylinderGeometry(0.035, 0.035, 0.06, 16), darkMetalMaterial);
                cameraBody.rotation.x = Math.PI / 2;
                cameraBody.position.set(0.05, -0.05, 0.16);

                const lens = new THREE.Mesh(new THREE.CircleGeometry(0.025, 16), new THREE.MeshStandardMaterial({ color: 0x000000, metalness: 1.0, roughness: 0.0 }));
                lens.position.set(0, 0.031, 0);
                lens.rotation.x = -Math.PI / 2;
                cameraBody.add(lens);
                satelliteGroup.add(cameraBody);

                // --- Orbit path ---
                const orbitRadius = 3.5;
                const orbitInclination = 1.2;
                const orbitPoints = [];
                const segments = 128;

                for (let i = 0; i <= segments; i++) {
                    const t = (i / segments) * Math.PI * 2;
                    const x = Math.cos(t) * orbitRadius;
                    const y = Math.sin(t * orbitInclination) * orbitRadius * 0.3;
                    const z = Math.sin(t) * orbitRadius;
                    orbitPoints.push(new THREE.Vector3(x, y, z));
                }

                const orbitGeometry = new THREE.BufferGeometry().setFromPoints(orbitPoints);
                const orbitMaterial = new THREE.LineBasicMaterial({
                    color: 0x00ffff,
                    transparent: true,
                    opacity: 0.4,
                });
                const orbitLine = new THREE.Line(orbitGeometry, orbitMaterial);
                earthGroup.add(orbitLine);

                // --- Ground station (Bangalore) ---
                const lat = 12.9716;
                const lon = 77.5946;
                const phi = (90 - lat) * (Math.PI / 180);
                const theta = (lon + 180) * (Math.PI / 180);
                const stationRadius = 1.55;

                const stationX = -(stationRadius * Math.sin(phi) * Math.cos(theta));
                const stationZ = stationRadius * Math.sin(phi) * Math.sin(theta);
                const stationY = stationRadius * Math.cos(phi);

                const stationGeometry = new THREE.ConeGeometry(0.05, 0.15, 8);
                const stationMaterial = new THREE.MeshBasicMaterial({ color: 0xff0000 });
                const station = new THREE.Mesh(stationGeometry, stationMaterial);
                station.position.set(stationX, stationY, stationZ);
                station.lookAt(earth.position);
                earthGroup.add(station);

                const stationLight = new THREE.PointLight(0xff0000, 1, 0.5);
                stationLight.position.set(stationX, stationY, stationZ);
                earthGroup.add(stationLight);

                // --- Custom Controls ---
                let isDragging = false;
                let previousMousePosition = { x: 0, y: 0 };
                let cameraRotation = { x: 0.3, y: 0 };

                const onMouseDown = (e) => {
                    isDragging = true;
                    previousMousePosition = { x: e.clientX, y: e.clientY };
                };

                const onMouseMove = (e) => {
                    if (!isDragging) return;

                    const deltaX = e.clientX - previousMousePosition.x;
                    const deltaY = e.clientY - previousMousePosition.y;

                    cameraRotation.y += deltaX * 0.005;
                    cameraRotation.x += deltaY * 0.005;
                    cameraRotation.x = Math.max(-Math.PI / 2 + 0.1, Math.min(Math.PI / 2 - 0.1, cameraRotation.x));

                    previousMousePosition = { x: e.clientX, y: e.clientY };
                };

                const onMouseUp = () => {
                    isDragging = false;
                };

                const onWheel = (e) => {
                    e.preventDefault();
                    const delta = e.deltaY * 0.01;
                    const distance = camera.position.length();
                    const newDistance = Math.max(3, Math.min(15, distance + delta));
                    camera.position.normalize().multiplyScalar(newDistance);
                };

                renderer.domElement.addEventListener('mousedown', onMouseDown);
                renderer.domElement.addEventListener('mousemove', onMouseMove);
                renderer.domElement.addEventListener('mouseup', onMouseUp);
                renderer.domElement.addEventListener('wheel', onWheel, { passive: false });

                // --- Animation Loop ---
                let time = 0;
                const orbitSpeed = 0.2;

                const animate = () => {
                    requestAnimationFrame(animate);

                    // Rotate earth slowly
                    earth.rotation.y += 0.001;
                    clouds.rotation.y += 0.0013;

                    const t = time * orbitSpeed;
                    const x = Math.cos(t) * orbitRadius;
                    const y = Math.sin(t * orbitInclination) * orbitRadius * 0.3;
                    const z = Math.sin(t) * orbitRadius;

                    satelliteGroup.position.set(x, y, z);
                    satelliteGroup.lookAt(earth.position);
                    satelliteGroup.rotation.y += 0.02;

                    const radius = camera.position.length();
                    camera.position.x = radius * Math.sin(cameraRotation.y) * Math.cos(cameraRotation.x);
                    camera.position.y = radius * Math.sin(cameraRotation.x);
                    camera.position.z = radius * Math.cos(cameraRotation.y) * Math.cos(cameraRotation.x);
                    camera.lookAt(earth.position);

                    renderer.render(scene, camera);
                };

                animate();

                // --- Window Resize Handler ---
                const handleResize = () => {
                    camera.aspect = window.innerWidth / window.innerHeight;
                    camera.updateProjectionMatrix();
                    renderer.setSize(window.innerWidth, window.innerHeight);

                    // Responsively adjust camera distance
                    const newDistance = window.innerWidth < 768 ? 11 : 6;
                    camera.position.normalize().multiplyScalar(newDistance);
                };

                window.addEventListener('resize', handleResize);

                // --- Cleanup ---
                return () => {
                    window.removeEventListener('resize', handleResize);
                    renderer.domElement.removeEventListener('mousedown', onMouseDown);
                    renderer.domElement.removeEventListener('mousemove', onMouseMove);
                    renderer.domElement.removeEventListener('mouseup', onMouseUp);
                    renderer.domElement.removeEventListener('wheel', onWheel);
                    mountRef.current?.removeChild(renderer.domElement);
                    renderer.dispose();
                };
            }, []);

            return (
                <div style={{ width: '100vw', height: '100vh', background: '#000000', position: 'relative', overflow: 'hidden' }}>






                    <div ref={mountRef} style={{ width: '100%', height: '100%' }} />
                </div>
            );
        }

        ReactDOM.render(<App />, document.getElementById('root'));
    </script>
</body>

</html>